<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>天体公転シミュレーション</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");
        if (!gl) {
            alert("WebGLがサポートされていません");
        }
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        
        const vertexShaderSource = `
            attribute vec2 a_position;
            uniform vec2 u_resolution;
            void main() {
                vec2 zeroToOne = a_position / u_resolution;
                vec2 zeroToTwo = zeroToOne * 2.0;
                vec2 clipSpace = zeroToTwo - 1.0;
                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
                gl_PointSize = 5.0;
            }
        `;
        
        const fragmentShaderSource = `
            precision mediump float;
            uniform vec4 u_color;
            void main() {
                gl_FragColor = u_color;
            }
        `;
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }
        
        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
        const colorUniformLocation = gl.getUniformLocation(program, "u_color");
        
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        
        gl.useProgram(program);
        gl.enableVertexAttribArray(positionAttributeLocation);
        
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        
        gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
        
        const gui = new dat.GUI();
        const settings = { numPlanets: 3 };
        
        let planets = [];
        function createPlanets(num) {
            planets = [];
            for (let i = 0; i < num; i++) {
                planets.push({
                    radius: Math.random() * 200 + 50,
                    angle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.02 + 0.005,
                    size: Math.random() * 8 + 2,
                    color: [Math.random(), Math.random(), Math.random(), 1]
                });
            }
        }
        createPlanets(settings.numPlanets);
        gui.add(settings, "numPlanets", 1, 10, 1).onChange(createPlanets);
        
        function drawScene() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            const star = [canvas.width / 2, canvas.height / 2];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(star), gl.STATIC_DRAW);
            gl.uniform4f(colorUniformLocation, 1, 1, 0, 1);
            gl.drawArrays(gl.POINTS, 0, 1);
            
            planets.forEach(planet => {
                planet.angle += planet.speed;
                const x = canvas.width / 2 + Math.cos(planet.angle) * planet.radius;
                const y = canvas.height / 2 + Math.sin(planet.angle) * planet.radius;
                
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x, y]), gl.STATIC_DRAW);
                gl.uniform4f(colorUniformLocation, ...planet.color);
                gl.drawArrays(gl.POINTS, 0, 1);
            });
            
            requestAnimationFrame(drawScene);
        }
        
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        drawScene();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL 天体公転シミュレーション</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; }
        #controls { width: 300px; padding: 10px; background: #ccc; }
        canvas { flex-grow: 1; }
    </style>
</head>
<body>
    <div id="controls">
        <label>天体数: <input type="number" id="numPlanets" min="1" max="10" value="3"></label>
        <button onclick="updatePlanets()">更新</button>
        <div id="planetSettings"></div>
    </div>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");
        
        if (!gl) {
            alert("WebGLがサポートされていません。");
        }
        
        canvas.width = window.innerWidth - 300;
        canvas.height = window.innerHeight;
        
        let planets = [];
        function createPlanetSettings() {
            let container = document.getElementById("planetSettings");
            container.innerHTML = "";
            let numPlanets = document.getElementById("numPlanets").value;
            planets = [];
            for (let i = 0; i < numPlanets; i++) {
                let div = document.createElement("div");
                div.innerHTML = `
                    <h4>天体 ${i+1}</h4>
                    サイズ: <input type="number" class="size" value="5"><br>
                    色: <input type="color" class="color" value="#ff0000"><br>
                    半径: <input type="number" class="radius" value="50"><br>
                    速度: <input type="number" class="speed" value="0.01" step="0.001"><br>
                `;
                container.appendChild(div);
                planets.push({ size: 5, color: [1, 0, 0], radius: 50, speed: 0.01, angle: 0 });
            }
        }
        
        function updatePlanets() {
            let settings = document.querySelectorAll("#planetSettings div");
            planets = [];
            settings.forEach((div, index) => {
                let size = parseFloat(div.querySelector(".size").value);
                let color = div.querySelector(".color").value;
                let radius = parseFloat(div.querySelector(".radius").value);
                let speed = parseFloat(div.querySelector(".speed").value);
                let r = parseInt(color.substring(1, 3), 16) / 255;
                let g = parseInt(color.substring(3, 5), 16) / 255;
                let b = parseInt(color.substring(5, 7), 16) / 255;
                planets.push({ size, color: [r, g, b], radius, speed, angle: 0 });
            });
        }
        
        createPlanetSettings();
        
        function render() {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            planets.forEach(planet => {
                planet.angle += planet.speed;
                let x = Math.cos(planet.angle) * planet.radius / canvas.width * 2;
                let y = Math.sin(planet.angle) * planet.radius / canvas.height * 2;
                drawCircle(x, y, planet.size / 200, planet.color);
            });
            drawCircle(0, 0, 0.05, [1, 1, 0]); // 恒星
            requestAnimationFrame(render);
        }
        
        function drawCircle(x, y, radius, color) {
            const segments = 30;
            let vertices = [];
            for (let i = 0; i <= segments; i++) {
                let theta = (i / segments) * 2 * Math.PI;
                vertices.push(x + radius * Math.cos(theta), y + radius * Math.sin(theta));
            }
            let buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            
            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, `
                attribute vec2 coordinates;
                void main(void) {
                    gl_Position = vec4(coordinates, 0.0, 1.0);
                }
            `);
            gl.compileShader(vertexShader);
            
            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, `
                precision mediump float;
                uniform vec3 color;
                void main(void) {
                    gl_FragColor = vec4(color, 1.0);
                }
            `);
            gl.compileShader(fragmentShader);
            
            let shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);
            
            let coord = gl.getAttribLocation(shaderProgram, "coordinates");
            gl.enableVertexAttribArray(coord);
            gl.vertexAttribPointer(coord, 2, gl.FLOAT, false, 0, 0);
            
            let colorLocation = gl.getUniformLocation(shaderProgram, "color");
            gl.uniform3fv(colorLocation, new Float32Array(color));
            
            gl.drawArrays(gl.TRIANGLE_FAN, 0, segments + 1);
        }
        
        render();
    </script>
</body>
</html>
